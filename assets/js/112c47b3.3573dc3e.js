"use strict";(globalThis.webpackChunkmy_web=globalThis.webpackChunkmy_web||[]).push([[4566],{4822:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"book/assessments/gazebo-implementation","title":"Gazebo Implementation Project","description":"Implementing humanoid robot simulation in Gazebo with physics, sensors, and control","source":"@site/docs/book/assessments/gazebo-implementation.md","sourceDirName":"book/assessments","slug":"/book/assessments/gazebo-implementation","permalink":"/physical-ai-robotics-textbook/docs/book/assessments/gazebo-implementation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/book/assessments/gazebo-implementation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Gazebo Implementation Project","sidebar_position":3,"description":"Implementing humanoid robot simulation in Gazebo with physics, sensors, and control"},"sidebar":"bookSidebar","previous":{"title":"ROS 2 Package Project","permalink":"/physical-ai-robotics-textbook/docs/book/assessments/ros2-package-project"},"next":{"title":"Comprehensive Capstone Project","permalink":"/physical-ai-robotics-textbook/docs/book/assessments/comprehensive-capstone"}}');var t=i(4848),a=i(8453);const r={title:"Gazebo Implementation Project",sidebar_position:3,description:"Implementing humanoid robot simulation in Gazebo with physics, sensors, and control"},s="Gazebo Implementation Project",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Project Requirements",id:"project-requirements",level:2},{value:"Core Requirements",id:"core-requirements",level:3},{value:"Humanoid-Specific Requirements",id:"humanoid-specific-requirements",level:3},{value:"Project Structure",id:"project-structure",level:2},{value:"Directory Structure",id:"directory-structure",level:3},{value:"URDF/XACRO Model Development",id:"urdfxacro-model-development",level:2},{value:"Complete Humanoid URDF",id:"complete-humanoid-urdf",level:3},{value:"Gazebo Plugins Development",id:"gazebo-plugins-development",level:2},{value:"Balance Control Plugin",id:"balance-control-plugin",level:3},{value:"Environment Creation",id:"environment-creation",level:2},{value:"Custom World File",id:"custom-world-file",level:3},{value:"Control System Integration",id:"control-system-integration",level:2},{value:"ROS 2 Controllers Configuration",id:"ros-2-controllers-configuration",level:3},{value:"Sensor Integration",id:"sensor-integration",level:2},{value:"IMU Configuration",id:"imu-configuration",level:3},{value:"Camera Configuration",id:"camera-configuration",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"Test Scenarios",id:"test-scenarios",level:3},{value:"Launch Files",id:"launch-files",level:2},{value:"Main Simulation Launch",id:"main-simulation-launch",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Physics Parameters",id:"physics-parameters",level:3},{value:"Troubleshooting Guide",id:"troubleshooting-guide",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Evaluation Criteria",id:"evaluation-criteria",level:2},{value:"Technical Requirements (60%)",id:"technical-requirements-60",level:3},{value:"Implementation Quality (25%)",id:"implementation-quality-25",level:3},{value:"Testing and Validation (15%)",id:"testing-and-validation-15",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Optional Enhancements",id:"optional-enhancements",level:3}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"gazebo-implementation-project",children:"Gazebo Implementation Project"})}),"\n",(0,t.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"This project requires students to implement a complete humanoid robot simulation in Gazebo, including accurate physics modeling, sensor simulation, and control systems. Students will learn to create realistic simulation environments that closely match real-world robot behavior."}),"\n",(0,t.jsx)(e.h2,{id:"project-requirements",children:"Project Requirements"}),"\n",(0,t.jsx)(e.h3,{id:"core-requirements",children:"Core Requirements"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Humanoid Robot Model"}),": Complete URDF model with realistic joint limits and dynamics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physics Simulation"}),": Accurate physics modeling with proper mass, inertia, and friction properties"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor Integration"}),": Implementation of multiple sensor types (IMU, cameras, LiDAR, force/torque)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Control Systems"}),": Integration with ROS 2 control frameworks"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Environment Creation"}),": Custom environments for testing humanoid capabilities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Validation"}),": Comparison between simulated and expected behavior"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-specific-requirements",children:"Humanoid-Specific Requirements"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bipedal Locomotion"}),": Stable walking and balance simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Balance"}),": Center of mass and zero-moment point (ZMP) considerations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Multi-contact Points"}),": Feet, hands, and other contact surfaces"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stability Analysis"}),": Tools for analyzing balance and stability"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,t.jsx)(e.h3,{id:"directory-structure",children:"Directory Structure"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"gazebo_humanoid_simulation/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 controllers.yaml\n\u2502   \u251c\u2500\u2500 gazebo_params.yaml\n\u2502   \u2514\u2500\u2500 robot_properties.yaml\n\u251c\u2500\u2500 launch/\n\u2502   \u251c\u2500\u2500 robot_spawn.launch.py\n\u2502   \u251c\u2500\u2500 simulation_world.launch.py\n\u2502   \u2514\u2500\u2500 test_scenarios.launch.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 humanoid_robot/\n\u2502   \u2502   \u251c\u2500\u2500 model.urdf.xacro\n\u2502   \u2502   \u251c\u2500\u2500 materials/\n\u2502   \u2502   \u251c\u2500\u2500 meshes/\n\u2502   \u2502   \u2514\u2500\u2500 sensors/\n\u2502   \u2514\u2500\u2500 environments/\n\u2502       \u251c\u2500\u2500 indoor/\n\u2502       \u251c\u2500\u2500 outdoor/\n\u2502       \u2514\u2500\u2500 testing/\n\u251c\u2500\u2500 worlds/\n\u2502   \u251c\u2500\u2500 simple_room.world\n\u2502   \u251c\u2500\u2500 complex_environment.world\n\u2502   \u2514\u2500\u2500 testing_scenarios.world\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 gazebo_plugins/\n\u2502   \u2502   \u251c\u2500\u2500 balance_controller_plugin.cpp\n\u2502   \u2502   \u251c\u2500\u2500 sensor_interface_plugin.cpp\n\u2502   \u2502   \u2514\u2500\u2500 contact_manager_plugin.cpp\n\u2502   \u251c\u2500\u2500 control_nodes/\n\u2502   \u2502   \u251c\u2500\u2500 balance_controller_node.cpp\n\u2502   \u2502   \u251c\u2500\u2500 walk_generator_node.cpp\n\u2502   \u2502   \u2514\u2500\u2500 sensor_processor_node.cpp\n\u2502   \u2514\u2500\u2500 test_nodes/\n\u2502       \u251c\u2500\u2500 stability_test_node.cpp\n\u2502       \u251c\u2500\u2500 balance_analysis_node.cpp\n\u2502       \u2514\u2500\u2500 sensor_validation_node.cpp\n\u251c\u2500\u2500 scripts/\n\u2502   \u251c\u2500\u2500 generate_urdf.py\n\u2502   \u251c\u2500\u2500 validate_dynamics.py\n\u2502   \u2514\u2500\u2500 run_tests.sh\n\u2514\u2500\u2500 test/\n    \u251c\u2500\u2500 test_balance_control.cpp\n    \u251c\u2500\u2500 test_sensor_accuracy.cpp\n    \u2514\u2500\u2500 integration_tests.py\n"})}),"\n",(0,t.jsx)(e.h2,{id:"urdfxacro-model-development",children:"URDF/XACRO Model Development"}),"\n",(0,t.jsx)(e.h3,{id:"complete-humanoid-urdf",children:"Complete Humanoid URDF"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_robot">\n\n  \x3c!-- Constants --\x3e\n  <xacro:property name="PI" value="3.1415926535897931"/>\n  <xacro:property name="mass_torso" value="10.0"/>\n  <xacro:property name="mass_head" value="2.0"/>\n  <xacro:property name="mass_arm" value="1.5"/>\n  <xacro:property name="mass_leg" value="3.0"/>\n  <xacro:property name="density" value="1000"/>\n\n  \x3c!-- Materials --\x3e\n  <material name="black">\n    <color rgba="0.0 0.0 0.0 1.0"/>\n  </material>\n  <material name="blue">\n    <color rgba="0.0 0.0 0.8 1.0"/>\n  </material>\n  <material name="green">\n    <color rgba="0.0 0.8 0.0 1.0"/>\n  </material>\n  <material name="grey">\n    <color rgba="0.5 0.5 0.5 1.0"/>\n  </material>\n  <material name="orange">\n    <color rgba="1.0 0.4235294117647059 0.0392156862745098 1.0"/>\n  </material>\n  <material name="brown">\n    <color rgba="0.8705882352941177 0.8117647058823529 0.7647058823529411 1.0"/>\n  </material>\n  <material name="red">\n    <color rgba="0.8 0.0 0.0 1.0"/>\n  </material>\n  <material name="white">\n    <color rgba="1.0 1.0 1.0 1.0"/>\n  </material>\n\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="0.0001"/>\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Torso --\x3e\n  <joint name="base_torso_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\n  </joint>\n\n  <link name="torso">\n    <visual>\n      <origin xyz="0 0 0.3" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.6" radius="0.15"/>\n      </geometry>\n      <material name="grey"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.3" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.6" radius="0.15"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 0.3" rpy="0 0 0"/>\n      <mass value="${mass_torso}"/>\n      <inertia\n        ixx="${mass_torso * (3*0.15*0.15 + 0.6*0.6)/12}"\n        ixy="0" ixz="0"\n        iyy="${mass_torso * (3*0.15*0.15 + 0.6*0.6)/12}"\n        iyz="0"\n        izz="${mass_torso * 0.15*0.15 / 2}"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <joint name="torso_head_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.65" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-PI/2}" upper="${PI/2}" effort="100" velocity="1.0"/>\n    <dynamics damping="0.1" friction="0.0"/>\n  </joint>\n\n  <link name="head">\n    <visual>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n      <material name="white"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <mass value="${mass_head}"/>\n      <inertia\n        ixx="${2*mass_head*0.15*0.15/5}"\n        ixy="0" ixz="0"\n        iyy="${2*mass_head*0.15*0.15/5}"\n        iyz="0"\n        izz="${2*mass_head*0.15*0.15/5}"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Arm --\x3e\n  <joint name="torso_left_shoulder_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="left_upper_arm"/>\n    <origin xyz="0.15 0 0.5" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-PI/2}" upper="${PI/2}" effort="50" velocity="1.0"/>\n    <dynamics damping="0.1" friction="0.0"/>\n  </joint>\n\n  <link name="left_upper_arm">\n    <visual>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.3" radius="0.05"/>\n      </geometry>\n      <material name="orange"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.3" radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <mass value="${mass_arm}"/>\n      <inertia\n        ixx="${mass_arm * (3*0.05*0.05 + 0.3*0.3)/12}"\n        ixy="0" ixz="0"\n        iyy="${mass_arm * (3*0.05*0.05 + 0.3*0.3)/12}"\n        iyz="0"\n        izz="${mass_arm * 0.05*0.05 / 2}"/>\n    </inertial>\n  </link>\n\n  <joint name="left_elbow_joint" type="revolute">\n    <parent link="left_upper_arm"/>\n    <child link="left_lower_arm"/>\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="${-PI/2}" upper="${PI/2}" effort="30" velocity="1.0"/>\n    <dynamics damping="0.1" friction="0.0"/>\n  </joint>\n\n  <link name="left_lower_arm">\n    <visual>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.3" radius="0.04"/>\n      </geometry>\n      <material name="orange"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.3" radius="0.04"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <mass value="${mass_arm*0.7}"/>\n      <inertia\n        ixx="${mass_arm*0.7 * (3*0.04*0.04 + 0.3*0.3)/12}"\n        ixy="0" ixz="0"\n        iyy="${mass_arm*0.7 * (3*0.04*0.04 + 0.3*0.3)/12}"\n        iyz="0"\n        izz="${mass_arm*0.7 * 0.04*0.04 / 2}"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Leg --\x3e\n  <joint name="torso_left_hip_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="left_thigh"/>\n    <origin xyz="0.05 0 0" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-PI/2}" upper="${PI/2}" effort="100" velocity="1.0"/>\n    <dynamics damping="0.2" friction="0.0"/>\n  </joint>\n\n  <link name="left_thigh">\n    <visual>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.5" radius="0.08"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.5" radius="0.08"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <mass value="${mass_leg}"/>\n      <inertia\n        ixx="${mass_leg * (3*0.08*0.08 + 0.5*0.5)/12}"\n        ixy="0" ixz="0"\n        iyy="${mass_leg * (3*0.08*0.08 + 0.5*0.5)/12}"\n        iyz="0"\n        izz="${mass_leg * 0.08*0.08 / 2}"/>\n    </inertial>\n  </link>\n\n  <joint name="left_knee_joint" type="revolute">\n    <parent link="left_thigh"/>\n    <child link="left_shin"/>\n    <origin xyz="0 0 -0.5" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-PI/2}" upper="0" effort="80" velocity="1.0"/>\n    <dynamics damping="0.2" friction="0.0"/>\n  </joint>\n\n  <link name="left_shin">\n    <visual>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.5" radius="0.07"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.5" radius="0.07"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <mass value="${mass_leg*0.9}"/>\n      <inertia\n        ixx="${mass_leg*0.9 * (3*0.07*0.07 + 0.5*0.5)/12}"\n        ixy="0" ixz="0"\n        iyy="${mass_leg*0.9 * (3*0.07*0.07 + 0.5*0.5)/12}"\n        iyz="0"\n        izz="${mass_leg*0.9 * 0.07*0.07 / 2}"/>\n    </inertial>\n  </link>\n\n  <joint name="left_ankle_joint" type="revolute">\n    <parent link="left_shin"/>\n    <child link="left_foot"/>\n    <origin xyz="0 0 -0.5" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-PI/4}" upper="${PI/4}" effort="50" velocity="1.0"/>\n    <dynamics damping="0.1" friction="0.0"/>\n  </joint>\n\n  <link name="left_foot">\n    <visual>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n      <material name="black"/>\n    </visual>\n    <collision>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <mass value="1.0"/>\n      <inertia\n        ixx="0.01" ixy="0" ixz="0"\n        iyy="0.01" iyz="0"\n        izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Right Leg (mirrored) --\x3e\n  <joint name="torso_right_hip_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="right_thigh"/>\n    <origin xyz="-0.05 0 0" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-PI/2}" upper="${PI/2}" effort="100" velocity="1.0"/>\n    <dynamics damping="0.2" friction="0.0"/>\n  </joint>\n\n  <link name="right_thigh">\n    <visual>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.5" radius="0.08"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.5" radius="0.08"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <mass value="${mass_leg}"/>\n      <inertia\n        ixx="${mass_leg * (3*0.08*0.08 + 0.5*0.5)/12}"\n        ixy="0" ixz="0"\n        iyy="${mass_leg * (3*0.08*0.08 + 0.5*0.5)/12}"\n        iyz="0"\n        izz="${mass_leg * 0.08*0.08 / 2}"/>\n    </inertial>\n  </link>\n\n  <joint name="right_knee_joint" type="revolute">\n    <parent link="right_thigh"/>\n    <child link="right_shin"/>\n    <origin xyz="0 0 -0.5" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-PI/2}" upper="0" effort="80" velocity="1.0"/>\n    <dynamics damping="0.2" friction="0.0"/>\n  </joint>\n\n  <link name="right_shin">\n    <visual>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.5" radius="0.07"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <geometry>\n        <capsule length="0.5" radius="0.07"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 -0.25" rpy="0 0 0"/>\n      <mass value="${mass_leg*0.9}"/>\n      <inertia\n        ixx="${mass_leg*0.9 * (3*0.07*0.07 + 0.5*0.5)/12}"\n        ixy="0" ixz="0"\n        iyy="${mass_leg*0.9 * (3*0.07*0.07 + 0.5*0.5)/12}"\n        iyz="0"\n        izz="${mass_leg*0.9 * 0.07*0.07 / 2}"/>\n    </inertial>\n  </link>\n\n  <joint name="right_ankle_joint" type="revolute">\n    <parent link="right_shin"/>\n    <child link="right_foot"/>\n    <origin xyz="0 0 -0.5" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-PI/4}" upper="${PI/4}" effort="50" velocity="1.0"/>\n    <dynamics damping="0.1" friction="0.0"/>\n  </joint>\n\n  <link name="right_foot">\n    <visual>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n      <material name="black"/>\n    </visual>\n    <collision>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <mass value="1.0"/>\n      <inertia\n        ixx="0.01" ixy="0" ixz="0"\n        iyy="0.01" iyz="0"\n        izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Gazebo Plugins --\x3e\n  <gazebo>\n    <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\n      <robotNamespace>/humanoid</robotNamespace>\n      <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Sensors --\x3e\n  <xacro:include filename="$(find gazebo_humanoid_simulation)/urdf/imu.xacro"/>\n  <xacro:include filename="$(find gazebo_humanoid_simulation)/urdf/camera.xacro"/>\n  <xacro:include filename="$(find gazebo_humanoid_simulation)/urdf/lidar.xacro"/>\n\n</robot>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"gazebo-plugins-development",children:"Gazebo Plugins Development"}),"\n",(0,t.jsx)(e.h3,{id:"balance-control-plugin",children:"Balance Control Plugin"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// include/gazebo_humanoid_simulation/balance_control_plugin.h\n#ifndef GAZEBO_HUMANOID_BALANCE_CONTROL_PLUGIN_H\n#define GAZEBO_HUMANOID_BALANCE_CONTROL_PLUGIN_H\n\n#include <gazebo/common/Plugin.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/transport/TransportTypes.hh>\n#include <gazebo/msgs/MessageTypes.hh>\n#include <gazebo/common/Events.hh>\n#include <ignition/math/Pose3.hh>\n#include <ignition/math/Vector3.hh>\n#include <ros/ros.h>\n#include <geometry_msgs/WrenchStamped.h>\n#include <std_msgs/Float64.h>\n\nnamespace gazebo {\n\nclass BalanceControlPlugin : public ModelPlugin {\npublic:\n  BalanceControlPlugin();\n  virtual ~BalanceControlPlugin();\n\n  virtual void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf);\n  virtual void Reset();\n\nprivate:\n  void UpdateChild();\n  void OnContact(const boost::shared_ptr<const gazebo::msgs::Contacts> &_msg);\n  ignition::math::Vector3<double> ComputeZMP();\n  void ComputeBalanceControl();\n  void PublishBalanceData();\n\nprivate:\n  physics::ModelPtr model;\n  physics::PhysicsEnginePtr physics;\n  event::ConnectionPtr update_connection_;\n\n  // Joint controllers\n  std::vector<physics::JointPtr> joints;\n  std::vector<std::string> joint_names;\n\n  // Balance control parameters\n  double balance_gain;\n  double com_height;\n  double zmp_threshold;\n  bool balance_enabled;\n\n  // Sensors\n  physics::LinkPtr torso_link;\n  physics::LinkPtr left_foot_link;\n  physics::LinkPtr right_foot_link;\n\n  // ROS interface\n  ros::NodeHandle* rosnode_;\n  ros::Publisher balance_pub_;\n  ros::Subscriber balance_cmd_sub_;\n\n  // Contact information\n  std::vector<std::string> contacts;\n\n  // Timing\n  ros::Time last_update_time;\n};\n\n}\n#endif\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'// src/balance_control_plugin.cpp\n#include <gazebo_humanoid_simulation/balance_control_plugin.h>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/sensors/sensors.hh>\n#include <thread>\n\nnamespace gazebo {\n\nBalanceControlPlugin::BalanceControlPlugin() : balance_gain(1.0),\n                                               com_height(0.8),\n                                               zmp_threshold(0.05),\n                                               balance_enabled(true) {\n}\n\nvoid BalanceControlPlugin::Load(physics::ModelPtr _model, sdf::ElementPtr _sdf) {\n  this->model = _model;\n  this->physics = _model->GetWorld()->Physics();\n\n  // Get links\n  this->torso_link = _model->GetLink("torso");\n  this->left_foot_link = _model->GetLink("left_foot");\n  this->right_foot_link = _model->GetLink("right_foot");\n\n  // Get joints\n  std::vector<std::string> joint_names_list = {\n    "torso_left_hip_joint", "left_knee_joint", "left_ankle_joint",\n    "torso_right_hip_joint", "right_knee_joint", "right_ankle_joint",\n    "torso_left_shoulder_joint", "left_elbow_joint",\n    "torso_right_shoulder_joint", "right_elbow_joint",\n    "torso_head_joint"\n  };\n\n  for (const auto& name : joint_names_list) {\n    physics::JointPtr joint = _model->GetJoint(name);\n    if (joint) {\n      joints.push_back(joint);\n      joint_names.push_back(name);\n    }\n  }\n\n  // Load parameters\n  if (_sdf->HasElement("balance_gain")) {\n    balance_gain = _sdf->Get<double>("balance_gain");\n  }\n  if (_sdf->HasElement("zmp_threshold")) {\n    zmp_threshold = _sdf->Get<double>("zmp_threshold");\n  }\n\n  // Initialize ROS\n  if (!ros::isInitialized()) {\n    int argc = 0;\n    char** argv = NULL;\n    ros::init(argc, argv, "gazebo_balance_control", ros::init_options::NoSigintHandler);\n  }\n\n  this->rosnode_ = new ros::NodeHandle("balance_control");\n\n  // Publishers and subscribers\n  this->balance_pub_ = this->rosnode_->advertise<geometry_msgs::WrenchStamped>(\n    "balance_state", 10);\n\n  // Connect to world update event\n  this->update_connection_ = event::Events::ConnectWorldUpdateBegin(\n      boost::bind(&BalanceControlPlugin::UpdateChild, this));\n\n  gzdbg << "Balance Control Plugin loaded for model " << _model->GetName() << std::endl;\n}\n\nvoid BalanceControlPlugin::UpdateChild() {\n  if (!balance_enabled) return;\n\n  // Compute current ZMP\n  ignition::math::Vector3<double> zmp = ComputeZMP();\n\n  // Compute balance correction\n  ComputeBalanceControl();\n\n  // Publish balance data\n  PublishBalanceData();\n}\n\nignition::math::Vector3<double> BalanceControlPlugin::ComputeZMP() {\n  // Compute Zero-Moment Point (ZMP)\n  // This is a simplified implementation\n  // In reality, this would involve more complex physics calculations\n\n  if (!torso_link) return ignition::math::Vector3<double>(0, 0, 0);\n\n  // Get CoM position\n  ignition::math::Vector3<double> com = torso_link->WorldInertialPose().Pos();\n\n  // Get contact forces (simplified)\n  ignition::math::Vector3<double> total_force(0, 0, 0);\n  ignition::math::Vector3<double> total_moment(0, 0, 0);\n\n  // Calculate ZMP based on contact points and forces\n  // ZMP = CoM - (g/z_com) * (CoM_acceleration)\n  // For simulation, we\'ll use a simplified approach\n\n  // Calculate based on foot contacts\n  ignition::math::Vector3<double> left_foot_pos = left_foot_link->WorldInertialPose().Pos();\n  ignition::math::Vector3<double> right_foot_pos = right_foot_link->WorldInertialPose().Pos();\n\n  // Average of foot positions as approximate ZMP\n  ignition::math::Vector3<double> avg_foot_pos =\n    (left_foot_pos + right_foot_pos) / 2.0;\n\n  // Return ZMP relative to CoM\n  return avg_foot_pos - ignition::math::Vector3<double>(com.X(), com.Y(), 0);\n}\n\nvoid BalanceControlPlugin::ComputeBalanceControl() {\n  ignition::math::Vector3<double> zmp = ComputeZMP();\n\n  // Check if ZMP is within support polygon\n  double zmp_distance = sqrt(zmp.X()*zmp.X() + zmp.Y()*zmp.Y());\n\n  if (zmp_distance > zmp_threshold) {\n    // Apply corrective torques to joints to restore balance\n    // This is a simplified control approach\n\n    // Calculate correction based on ZMP deviation\n    double correction_x = -balance_gain * zmp.X();\n    double correction_y = -balance_gain * zmp.Y();\n\n    // Apply to hip and ankle joints for balance correction\n    for (size_t i = 0; i < joints.size(); ++i) {\n      physics::JointPtr joint = joints[i];\n\n      // Apply corrective torques based on joint type and position\n      if (joint->GetType() == physics::Joint::HINGE_JOINT) {\n        double torque = 0.0;\n\n        // Hip joints for CoM adjustment\n        if (joint->GetName().find("hip") != std::string::npos) {\n          if (joint->GetName().find("left") != std::string::npos) {\n            torque = correction_y;\n          } else {\n            torque = -correction_y;\n          }\n        }\n        // Ankle joints for fine balance\n        else if (joint->GetName().find("ankle") != std::string::npos) {\n          if (joint->GetName().find("left") != std::string::npos) {\n            torque = correction_x;\n          } else {\n            torque = -correction_x;\n          }\n        }\n\n        joint->SetForce(0, torque);\n      }\n    }\n  }\n}\n\nvoid BalanceControlPlugin::PublishBalanceData() {\n  geometry_msgs::WrenchStamped balance_msg;\n  balance_msg.header.stamp = ros::Time::now();\n  balance_msg.header.frame_id = "world";\n\n  ignition::math::Vector3<double> zmp = ComputeZMP();\n  balance_msg.wrench.force.x = zmp.X();\n  balance_msg.wrench.force.y = zmp.Y();\n  balance_msg.wrench.force.z = zmp.Z();\n\n  // Calculate balance metric\n  double balance_metric = sqrt(zmp.X()*zmp.X() + zmp.Y()*zmp.Y());\n  balance_msg.wrench.torque.z = balance_metric;\n\n  this->balance_pub_.publish(balance_msg);\n}\n\nvoid BalanceControlPlugin::Reset() {\n  // Reset balance control state\n  balance_enabled = true;\n}\n\nBalanceControlPlugin::~BalanceControlPlugin() {\n  // Disconnect from events\n  event::Events::DisconnectWorldUpdateBegin(this->update_connection_);\n\n  // Cleanup ROS\n  if (this->rosnode_) {\n    delete this->rosnode_;\n    this->rosnode_ = NULL;\n  }\n}\n\n// Register this plugin with the simulator\nGZ_REGISTER_MODEL_PLUGIN(BalanceControlPlugin)\n\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"environment-creation",children:"Environment Creation"}),"\n",(0,t.jsx)(e.h3,{id:"custom-world-file",children:"Custom World File"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.6">\n  <world name="humanoid_test_world">\n    \x3c!-- Include Gazebo environment --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Custom environment elements --\x3e\n    <light name="ambient_light" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>10</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.3 0.3 -1</direction>\n    </light>\n\n    \x3c!-- Indoor environment --\x3e\n    <model name="room_walls">\n      <static>true</static>\n      <link name="wall_link">\n        <visual name="wall_visual">\n          <geometry>\n            <box>\n              <size>10 0.2 3</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n          </material>\n        </visual>\n        <collision name="wall_collision">\n          <geometry>\n            <box>\n              <size>10 0.2 3</size>\n            </box>\n          </geometry>\n        </collision>\n      </link>\n      <pose>0 -5 1.5 0 0 0</pose>\n    </model>\n\n    \x3c!-- Obstacles for testing --\x3e\n    <model name="obstacle_box">\n      <pose>2 0 0.5 0 0 0</pose>\n      <link name="box_link">\n        <inertial>\n          <mass>5.0</mass>\n          <inertia>\n            <ixx>0.1</ixx>\n            <ixy>0</ixy>\n            <ixz>0</ixz>\n            <iyy>0.1</iyy>\n            <iyz>0</iyz>\n            <izz>0.1</izz>\n          </inertia>\n        </inertial>\n        <visual name="box_visual">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.6 0.4 0.2 1</ambient>\n            <diffuse>0.6 0.4 0.2 1</diffuse>\n          </material>\n        </visual>\n        <collision name="box_collision">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n        </collision>\n      </link>\n    </model>\n\n    \x3c!-- Sloped surface for balance testing --\x3e\n    <model name="sloped_surface">\n      <static>true</static>\n      <link name="slope_link">\n        <visual name="slope_visual">\n          <geometry>\n            <mesh>\n              <uri>file://meshes/slope.dae</uri>\n            </mesh>\n          </geometry>\n        </visual>\n        <collision name="slope_collision">\n          <geometry>\n            <mesh>\n              <uri>file://meshes/slope.dae</uri>\n            </mesh>\n          </geometry>\n        </collision>\n      </link>\n      <pose>5 0 0 0 0.2 0</pose>\n    </model>\n\n    \x3c!-- Humanoid robot spawn --\x3e\n    <include>\n      <name>humanoid_robot</name>\n      <uri>model://humanoid_robot</uri>\n      <pose>0 0 1 0 0 0</pose>\n    </include>\n\n    \x3c!-- Physics parameters --\x3e\n    <physics name="ode" type="ode">\n      <real_time_update_rate>1000</real_time_update_rate>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <gravity>0 0 -9.8</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"control-system-integration",children:"Control System Integration"}),"\n",(0,t.jsx)(e.h3,{id:"ros-2-controllers-configuration",children:"ROS 2 Controllers Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"# config/controllers.yaml\ncontroller_manager:\n  ros__parameters:\n    update_rate: 1000  # Hz\n\n    # Joint trajectory controller\n    joint_trajectory_controller:\n      type: joint_trajectory_controller/JointTrajectoryController\n\n    # Balance controller\n    balance_controller:\n      type: humanoid_control/BalanceController\n\n    # Force/torque controller\n    impedance_controller:\n      type: humanoid_control/ImpedanceController\n\n# Joint trajectory controller configuration\njoint_trajectory_controller:\n  ros__parameters:\n    joints:\n      - torso_left_hip_joint\n      - left_knee_joint\n      - left_ankle_joint\n      - torso_right_hip_joint\n      - right_knee_joint\n      - right_ankle_joint\n      - torso_left_shoulder_joint\n      - left_elbow_joint\n      - torso_right_shoulder_joint\n      - right_elbow_joint\n      - torso_head_joint\n\n    command_interfaces:\n      - position\n\n    state_interfaces:\n      - position\n      - velocity\n\n    state_publish_rate: 50.0\n    action_monitor_rate: 20.0\n    allow_partial_joints_goal: false\n    constraints:\n      stopped_velocity_tolerance: 0.01\n      goal_time: 0.0\n\n# Balance controller configuration\nbalance_controller:\n  ros__parameters:\n    kp_com: [100.0, 100.0, 0.0]  # Proportional gains for CoM control\n    kd_com: [10.0, 10.0, 0.0]    # Derivative gains for CoM control\n    kp_foot: [50.0, 50.0, 100.0] # Proportional gains for foot control\n    kd_foot: [5.0, 5.0, 10.0]    # Derivative gains for foot control\n    zmp_threshold: 0.05          # Maximum allowable ZMP deviation\n    com_height_ref: 0.85         # Reference CoM height\n    control_frequency: 500       # Balance control frequency\n\n# Impedance controller configuration\nimpedance_controller:\n  ros__parameters:\n    stiffness:\n      trans_x: 1000.0\n      trans_y: 1000.0\n      trans_z: 3000.0\n      rot_x: 300.0\n      rot_y: 300.0\n      rot_z: 300.0\n\n    damping_ratio: 1.0\n    control_mode: impedance\n"})}),"\n",(0,t.jsx)(e.h2,{id:"sensor-integration",children:"Sensor Integration"}),"\n",(0,t.jsx)(e.h3,{id:"imu-configuration",children:"IMU Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- urdf/imu.xacro --\x3e\n<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro">\n  <xacro:macro name="imu_macro" params="name parent_link *origin">\n    <joint name="${name}_joint" type="fixed">\n      <xacro:insert_block name="origin"/>\n      <parent link="${parent_link}"/>\n      <child link="${name}_link"/>\n    </joint>\n\n    <link name="${name}_link">\n      <inertial>\n        <mass value="0.01"/>\n        <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\n      </inertial>\n    </link>\n\n    <gazebo reference="${name}_link">\n      <sensor name="${name}_sensor" type="imu">\n        <always_on>true</always_on>\n        <update_rate>100</update_rate>\n        <visualize>false</visualize>\n        <topic>__default_topic__</topic>\n        <pose>0 0 0 0 0 0</pose>\n        <imu>\n          <noise>\n            <type>gaussian</type>\n            <rate>\n              <mean>0.0</mean>\n              <stddev>2e-4</stddev>\n              <bias_mean>0.0000075</bias_mean>\n              <bias_stddev>0.0000008</bias_stddev>\n            </rate>\n            <accel>\n              <mean>0.0</mean>\n              <stddev>1.7e-2</stddev>\n              <bias_mean>0.0</bias_mean>\n              <bias_stddev>0.005</bias_stddev>\n            </accel>\n          </noise>\n        </imu>\n      </sensor>\n    </gazebo>\n  </xacro:macro>\n</robot>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"camera-configuration",children:"Camera Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- urdf/camera.xacro --\x3e\n<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro">\n  <xacro:macro name="camera_macro" params="name parent_link *origin">\n    <joint name="${name}_joint" type="fixed">\n      <xacro:insert_block name="origin"/>\n      <parent link="${parent_link}"/>\n      <child link="${name}_link"/>\n    </joint>\n\n    <link name="${name}_link">\n      <inertial>\n        <mass value="0.01"/>\n        <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\n      </inertial>\n      <visual>\n        <geometry>\n          <box size="0.02 0.04 0.02"/>\n        </geometry>\n        <material name="black"/>\n      </visual>\n      <collision>\n        <geometry>\n          <box size="0.02 0.04 0.02"/>\n        </geometry>\n      </collision>\n    </link>\n\n    <gazebo reference="${name}_link">\n      <sensor name="${name}_camera" type="camera">\n        <update_rate>30</update_rate>\n        <camera name="head">\n          <horizontal_fov>1.3962634</horizontal_fov>\n          <image>\n            <width>640</width>\n            <height>480</height>\n            <format>R8G8B8</format>\n          </image>\n          <clip>\n            <near>0.1</near>\n            <far>100</far>\n          </clip>\n          <noise>\n            <type>gaussian</type>\n            <mean>0.0</mean>\n            <stddev>0.007</stddev>\n          </noise>\n        </camera>\n        <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n          <frame_name>${name}_optical_frame</frame_name>\n          <min_depth>0.1</min_depth>\n          <max_depth>100</max_depth>\n        </plugin>\n      </sensor>\n    </gazebo>\n  </xacro:macro>\n</robot>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,t.jsx)(e.h3,{id:"test-scenarios",children:"Test Scenarios"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# test/scenario_tests.py\nimport unittest\nimport rospy\nimport rostest\nfrom geometry_msgs.msg import WrenchStamped\nfrom std_msgs.msg import Float64\nimport time\n\nclass TestBalanceControl(unittest.TestCase):\n    def setUp(self):\n        rospy.init_node(\'balance_test_node\', anonymous=True)\n        self.balance_sub = rospy.Subscriber(\'/balance_state\', WrenchStamped, self.balance_callback)\n        self.balance_msg = None\n        self.received = False\n\n    def balance_callback(self, msg):\n        self.balance_msg = msg\n        self.received = True\n\n    def test_initial_balance(self):\n        """Test that robot starts in balanced state"""\n        # Wait for initial balance message\n        timeout = rospy.Duration.from_sec(5.0)\n        start_time = rospy.Time.now()\n\n        while not self.received and (rospy.Time.now() - start_time) < timeout:\n            rospy.sleep(0.1)\n\n        self.assertTrue(self.received, "Balance message not received")\n        self.assertIsNotNone(self.balance_msg, "Balance message is None")\n\n        # Check initial balance is within acceptable range\n        balance_metric = self.balance_msg.wrench.torque.z\n        self.assertLess(balance_metric, 0.1, "Initial balance exceeds threshold")\n\n    def test_disturbance_response(self):\n        """Test robot response to external disturbance"""\n        # Apply external force to robot\n        # This would require a service call or publisher to apply force\n        # For now, we\'ll just verify the test structure\n\n        # Wait for balance to stabilize after disturbance\n        time.sleep(2.0)\n\n        # Check that balance is restored\n        if self.balance_msg:\n            balance_after_disturbance = self.balance_msg.wrench.torque.z\n            self.assertLess(balance_after_disturbance, 0.2, "Balance not restored after disturbance")\n\nclass TestLocomotion(unittest.TestCase):\n    def setUp(self):\n        rospy.init_node(\'locomotion_test_node\', anonymous=True)\n        self.step_count = 0\n        self.step_sub = rospy.Subscriber(\'/step_events\', Float64, self.step_callback)\n\n    def step_callback(self, msg):\n        self.step_count += 1\n\n    def test_forward_locomotion(self):\n        """Test basic forward walking"""\n        initial_steps = self.step_count\n\n        # Command robot to walk forward\n        # This would involve sending commands to the walk controller\n\n        # Wait for walking to occur\n        time.sleep(5.0)\n\n        # Verify steps were taken\n        steps_taken = self.step_count - initial_steps\n        self.assertGreater(steps_taken, 0, "No steps detected during forward walking")\n\nif __name__ == \'__main__\':\n    rostest.rosrun(\'gazebo_humanoid_simulation\', \'test_balance_control\', TestBalanceControl)\n    rostest.rosrun(\'gazebo_humanoid_simulation\', \'test_locomotion\', TestLocomotion)\n'})}),"\n",(0,t.jsx)(e.h2,{id:"launch-files",children:"Launch Files"}),"\n",(0,t.jsx)(e.h3,{id:"main-simulation-launch",children:"Main Simulation Launch"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# launch/humanoid_simulation.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch arguments\n    world_arg = DeclareLaunchArgument(\n        'world',\n        default_value='humanoid_test_world',\n        description='Choose one of the world files from GAZEBO_MODEL_PATH'\n    )\n\n    robot_name_arg = DeclareLaunchArgument(\n        'robot_name',\n        default_value='humanoid_robot',\n        description='Name of the robot'\n    )\n\n    # Gazebo launch\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': PathJoinSubstitution([\n                FindPackageShare('gazebo_humanoid_simulation'),\n                'worlds',\n                LaunchConfiguration('world')\n            ])\n        }.items()\n    )\n\n    # Robot spawn node\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', LaunchConfiguration('robot_name'),\n            '-x', '0',\n            '-y', '0',\n            '-z', '1.0'\n        ],\n        output='screen'\n    )\n\n    # Controller manager\n    controller_manager = Node(\n        package='controller_manager',\n        executable='ros2_control_node',\n        parameters=[\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_humanoid_simulation'),\n                'config',\n                'controllers.yaml'\n            ])\n        ],\n        output='screen'\n    )\n\n    # Balance controller\n    balance_controller = Node(\n        package='gazebo_humanoid_simulation',\n        executable='balance_controller_node',\n        name='balance_controller',\n        output='screen'\n    )\n\n    # Sensor processor\n    sensor_processor = Node(\n        package='gazebo_humanoid_simulation',\n        executable='sensor_processor_node',\n        name='sensor_processor',\n        output='screen'\n    )\n\n    return LaunchDescription([\n        world_arg,\n        robot_name_arg,\n        gazebo,\n        spawn_entity,\n        controller_manager,\n        balance_controller,\n        sensor_processor\n    ])\n"})}),"\n",(0,t.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(e.h3,{id:"physics-parameters",children:"Physics Parameters"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# config/physics_params.yaml\ngazebo_physics:\n  # Time stepping\n  max_step_size: 0.001\n  real_time_update_rate: 1000\n  real_time_factor: 1.0\n\n  # Solver parameters\n  solver_type: "ode"\n  ode_solver:\n    type: "quick"\n    iters: 100\n    sor: 1.3\n\n  # Constraints\n  constraints:\n    cfm: 0.0\n    erp: 0.2\n    contact_max_correcting_vel: 100.0\n    contact_surface_layer: 0.001\n\n  # Contacts\n  contact:\n    collide_without_contact: false\n    collide_without_contact_bitmask: 1\n    bitmask: 1\n\n  # Gravity\n  gravity: [0.0, 0.0, -9.8]\n'})}),"\n",(0,t.jsx)(e.h2,{id:"troubleshooting-guide",children:"Troubleshooting Guide"}),"\n",(0,t.jsx)(e.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Instability in Simulation"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Check joint limits and stiffness parameters"}),"\n",(0,t.jsx)(e.li,{children:"Verify mass and inertia properties"}),"\n",(0,t.jsx)(e.li,{children:"Adjust physics solver parameters"}),"\n",(0,t.jsx)(e.li,{children:"Increase simulation frequency"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Balance Control Problems"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Verify IMU placement and calibration"}),"\n",(0,t.jsx)(e.li,{children:"Check ZMP calculation algorithm"}),"\n",(0,t.jsx)(e.li,{children:"Tune balance control gains"}),"\n",(0,t.jsx)(e.li,{children:"Validate contact detection"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Performance Issues"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Reduce model complexity"}),"\n",(0,t.jsx)(e.li,{children:"Adjust update rates"}),"\n",(0,t.jsx)(e.li,{children:"Optimize collision meshes"}),"\n",(0,t.jsx)(e.li,{children:"Use simpler physics approximations"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Sensor Noise"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Calibrate sensor noise parameters"}),"\n",(0,t.jsx)(e.li,{children:"Implement filtering algorithms"}),"\n",(0,t.jsx)(e.li,{children:"Check sensor placement"}),"\n",(0,t.jsx)(e.li,{children:"Verify coordinate frames"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"evaluation-criteria",children:"Evaluation Criteria"}),"\n",(0,t.jsx)(e.h3,{id:"technical-requirements-60",children:"Technical Requirements (60%)"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Model Accuracy"}),": URDF/XACRO model correctly represents humanoid kinematics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physics Simulation"}),": Accurate physics behavior matching real-world expectations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Control Integration"}),": Proper integration with ROS 2 control systems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor Simulation"}),": Accurate sensor data generation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stability"}),": Robot maintains balance under various conditions"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-quality-25",children:"Implementation Quality (25%)"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Code Quality"}),": Clean, well-documented, following ROS 2 conventions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Modularity"}),": Well-structured, reusable components"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Error Handling"}),": Robust error detection and recovery"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Performance"}),": Efficient resource usage and real-time capability"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"testing-and-validation-15",children:"Testing and Validation (15%)"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Test Coverage"}),": Comprehensive testing of all features"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Validation"}),": Comparison with expected behavior"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Documentation"}),": Clear documentation of setup and usage"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reproducibility"}),": Clear instructions for reproducing results"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,t.jsx)(e.h3,{id:"optional-enhancements",children:"Optional Enhancements"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic Environment"}),": Moving obstacles and changing terrain"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Learning-Based Control"}),": Reinforcement learning for gait optimization"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Multi-Robot Simulation"}),": Coordination between multiple humanoid robots"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Advanced Sensors"}),": Force/torque sensors, tactile sensors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-Time Visualization"}),": Advanced visualization of planning and control"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This project provides comprehensive experience in Gazebo simulation for humanoid robotics, covering model creation, physics simulation, sensor integration, and control system development. Students will gain practical experience in creating realistic simulation environments that closely match real-world robot behavior."})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(m,{...n})}):m(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>s});var o=i(6540);const t={},a=o.createContext(t);function r(n){const e=o.useContext(a);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),o.createElement(a.Provider,{value:e},n.children)}}}]);