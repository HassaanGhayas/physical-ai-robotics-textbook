"use strict";(globalThis.webpackChunkmy_web=globalThis.webpackChunkmy_web||[]).push([[9038],{1518:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"book/hardware-requirements/index","title":"Hardware Requirements","description":"Essential hardware requirements for Physical AI & Humanoid Robotics","source":"@site/docs/book/hardware-requirements/index.md","sourceDirName":"book/hardware-requirements","slug":"/book/hardware-requirements/","permalink":"/physical-ai-robotics-textbook/docs/book/hardware-requirements/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/book/hardware-requirements/index.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Hardware Requirements","sidebar_position":1,"description":"Essential hardware requirements for Physical AI & Humanoid Robotics"},"sidebar":"bookSidebar","previous":{"title":"Performance","permalink":"/physical-ai-robotics-textbook/docs/documentation/performance"},"next":{"title":"Digital Twin Workstation","permalink":"/physical-ai-robotics-textbook/docs/book/hardware-requirements/digital-twin-workstation"}}');var o=r(4848),t=r(8453);const s={title:"Hardware Requirements",sidebar_position:1,description:"Essential hardware requirements for Physical AI & Humanoid Robotics"},a="Hardware Requirements",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Module Objectives",id:"module-objectives",level:2},{value:"Recommended Workstation Specifications",id:"recommended-workstation-specifications",level:2},{value:"Edge Computing for Robot Deployment",id:"edge-computing-for-robot-deployment",level:2},{value:"Sample Hardware Configuration Code",id:"sample-hardware-configuration-code",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"import HardwareSpecs from '@site/src/components/HardwareSpecs/HardwareSpecs';\nimport CodeExamples from '@site/src/components/CodeExamples/CodeExamples';\nimport TechnicalDiagrams from '@site/src/components/TechnicalDiagrams/TechnicalDiagrams';\nimport BookNavigation from '@site/src/components/BookNavigation/BookNavigation';\nimport ThemeSwitcher from '@site/src/components/ThemeSwitcher/ThemeSwitcher';"}),"\n",(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"hardware-requirements",children:"Hardware Requirements"})}),"\n",(0,o.jsx)(n.p,{children:"This module covers the essential hardware requirements for developing and deploying Physical AI and Humanoid Robotics systems. The hardware is categorized into three tiers:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The Digital Twin Workstation (Simulation)"}),"\n",(0,o.jsx)(n.li,{children:"The Edge Kit (Physical Deployment)"}),"\n",(0,o.jsx)(n.li,{children:"The Robot Lab"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"This course sits at the intersection of Physics Simulation, Visual Perception, and Generative AI. The hardware requirements are designed to provide students with the necessary tools to understand and implement embodied AI systems."}),"\n",(0,o.jsx)(n.h2,{id:"module-objectives",children:"Module Objectives"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this module, you will understand:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The critical hardware components for robotics and AI development"}),"\n",(0,o.jsx)(n.li,{children:"Performance requirements for different use cases"}),"\n",(0,o.jsx)(n.li,{children:"Cost considerations for various deployment scenarios"}),"\n",(0,o.jsx)(n.li,{children:"Trade-offs between different hardware options"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"recommended-workstation-specifications",children:"Recommended Workstation Specifications"}),"\n",(0,o.jsx)(n.p,{children:'<HardwareSpecs\nname="Digital Twin Workstation"\ncategory="Simulation & Development"\nspecs={{\ncpu: "AMD Ryzen 9 7950X or Intel i9-13900K",\ngpu: "NVIDIA RTX 4090 or RTX A6000",\nmemory: "64GB DDR5-5200",\nstorage: "2TB NVMe Gen 4 SSD + 8TB HDD",\npsu: "1000W 80+ Gold or higher",\ncooling: "AIO liquid cooling or high-end air cooler"\n}}\ncost={{\nprice: "~$4,000-$6,000",\nreasoning: "Required for running complex physics simulations and training AI models"\n}}\npros={[\n"Sufficient GPU power for Isaac Sim and other simulators",\n"Fast CPU for real-time physics simulation",\n"Large memory for complex scene rendering",\n"Future-proof for advanced projects"\n]}\ncons={[\n"High initial cost",\n"Significant power consumption",\n"Large physical footprint",\n"Requires good ventilation"\n]}\n/>'}),"\n",(0,o.jsx)(n.h2,{id:"edge-computing-for-robot-deployment",children:"Edge Computing for Robot Deployment"}),"\n",(0,o.jsx)(n.p,{children:'<HardwareSpecs\nname="Edge AI Kit"\ncategory="Robot Deployment"\nspecs={{\nprocessor: "NVIDIA Jetson Orin AGX (64GB)",\ncpu: "12-core ARM v8.4 64-bit",\ngpu: "2048-core NVIDIA Ampere GPU",\nmemory: "64GB LPDDR5",\nstorage: "32GB eMMC + microSD slot",\npower: "60W typical, 100W max"\n}}\ncost={{\nprice: "$1,499",\nreasoning: "Balanced performance and power efficiency for mobile robotics"\n}}\npros={[\n"High AI performance per watt",\n"Compact form factor",\n"NVIDIA Isaac ecosystem support",\n"Multiple sensor interfaces"\n]}\ncons={[\n"Limited expansion options",\n"Requires active cooling",\n"Higher cost per FLOP than workstation GPUs",\n"Thermal constraints in enclosed spaces"\n]}\n/>'}),"\n",(0,o.jsx)(n.h2,{id:"sample-hardware-configuration-code",children:"Sample Hardware Configuration Code"}),"\n",(0,o.jsx)(n.p,{children:'<CodeExamples\ntitle="Hardware Configuration Manager"\ndescription="Python code to manage and validate hardware configurations for robotics applications"\nlanguage="python"\ncode={`import json\nimport subprocess\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport psutil\nimport GPUtil'}),"\n",(0,o.jsx)(n.p,{children:'@dataclass\nclass HardwareSpecs:\n"""Data class to represent hardware specifications"""\ncpu_model: str\ncpu_cores: int\ncpu_threads: int\ngpu_model: str\ngpu_memory: int  # in MB\nsystem_memory: int  # in MB\nstorage_available: int  # in GB\nplatform: str'}),"\n",(0,o.jsx)(n.p,{children:'class HardwareValidator:\n"""Class to validate hardware configurations against requirements"""'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'def __init__(self):\n    self.current_specs = self._get_current_specs()\n\ndef _get_current_specs(self) -> HardwareSpecs:\n    """Get current system specifications"""\n    # Get CPU info\n    cpu_info = self._get_cpu_info()\n\n    # Get GPU info\n    gpu_info = self._get_gpu_info()\n\n    # Get memory info\n    memory_info = psutil.virtual_memory()\n    system_memory = memory_info.total // (1024**2)  # Convert to MB\n\n    # Get storage info\n    disk_info = psutil.disk_usage(\'/\')\n    storage_available = disk_info.free // (1024**3)  # Convert to GB\n\n    # Get platform info\n    platform_info = self._get_platform_info()\n\n    return HardwareSpecs(\n        cpu_model=cpu_info[\'model\'],\n        cpu_cores=cpu_info[\'cores\'],\n        cpu_threads=cpu_info[\'threads\'],\n        gpu_model=gpu_info[\'model\'],\n        gpu_memory=gpu_info[\'memory\'],\n        system_memory=system_memory,\n        storage_available=storage_available,\n        platform=platform_info\n    )\n\ndef _get_cpu_info(self) -> Dict:\n    """Get CPU information"""\n    # This is a simplified version - in practice you\'d use platform-specific commands\n    cpu_count = psutil.cpu_count()\n    cpu_count_logical = psutil.cpu_count(logical=True)\n\n    # Get CPU model (simplified)\n    try:\n        if psutil.LINUX:\n            with open(\'/proc/cpuinfo\', \'r\') as f:\n                for line in f:\n                    if line.startswith(\'model name\'):\n                        model = line.split(\':\')[1].strip()\n                        break\n        elif psutil.WINDOWS:\n            model = subprocess.check_output(\n                ["wmic", "cpu", "get", "name"],\n                text=True\n            ).split(\'\\\\n\')[1].strip()\n        else:\n            model = "Unknown CPU Model"\n    except:\n        model = "Unknown CPU Model"\n\n    return {\n        \'model\': model,\n        \'cores\': cpu_count or 0,\n        \'threads\': cpu_count_logical or 0\n    }\n\ndef _get_gpu_info(self) -> Dict:\n    """Get GPU information using GPUtil"""\n    gpus = GPUtil.getGPUs()\n    if gpus:\n        gpu = gpus[0]  # Get first GPU\n        return {\n            \'model\': gpu.name,\n            \'memory\': int(gpu.memoryTotal)  # in MB\n        }\n    else:\n        return {\n            \'model\': \'No GPU detected\',\n            \'memory\': 0\n        }\n\ndef _get_platform_info(self) -> str:\n    """Get platform information"""\n    import platform\n    return platform.platform()\n\ndef validate_requirements(self, min_requirements: Dict) -> Dict:\n    """Validate current specs against minimum requirements"""\n    results = {\n        \'cpu_cores\': self.current_specs.cpu_cores >= min_requirements.get(\'cpu_cores\', 0),\n        \'gpu_memory\': self.current_specs.gpu_memory >= min_requirements.get(\'gpu_memory\', 0),\n        \'system_memory\': self.current_specs.system_memory >= min_requirements.get(\'system_memory\', 0),\n        \'storage\': self.current_specs.storage_available >= min_requirements.get(\'storage_available\', 0),\n        \'platform_compatible\': min_requirements.get(\'platform\', self.current_specs.platform) in self.current_specs.platform\n    }\n\n    results[\'overall\'] = all([\n        results[\'cpu_cores\'],\n        results[\'gpu_memory\'],\n        results[\'system_memory\'],\n        results[\'storage\']\n    ])\n\n    return results\n\ndef get_recommendation(self, application_type: str) -> str:\n    """Get hardware recommendation based on application type"""\n    if application_type == "simulation":\n        return self._simulation_recommendation()\n    elif application_type == "deployment":\n        return self._deployment_recommendation()\n    else:\n        return "General purpose hardware recommendation: Contact system administrator."\n\ndef _simulation_recommendation(self) -> str:\n    """Get recommendation for simulation applications"""\n    if self.current_specs.gpu_memory < 12000:  # Less than 12GB\n        return "Insufficient GPU memory for complex simulations. Consider upgrading to GPU with 16GB+ memory."\n    elif self.current_specs.system_memory < 32768:  # Less than 32GB\n        return "Consider upgrading system memory to 64GB for complex physics simulations."\n    else:\n        return "Hardware is suitable for simulation applications."\n\ndef _deployment_recommendation(self) -> str:\n    """Get recommendation for deployment applications"""\n    if "Linux" not in self.current_specs.platform:\n        return "Robot deployment applications typically require Linux-based systems. Consider using embedded hardware like NVIDIA Jetson."\n    elif self.current_specs.gpu_memory < 4096:  # Less than 4GB\n        return "Insufficient GPU memory for real-time AI inference. Consider embedded AI hardware."\n    else:\n        return "Hardware is suitable for deployment applications."\n'})}),"\n",(0,o.jsx)(n.h1,{id:"example-usage",children:"Example usage"}),"\n",(0,o.jsxs)(n.p,{children:["if ",(0,o.jsx)(n.strong,{children:"name"}),' == "',(0,o.jsx)(n.strong,{children:"main"}),'":\nvalidator = HardwareValidator()']}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"# Define minimum requirements for Isaac Sim\nisaac_sim_requirements = {\n    'cpu_cores': 8,\n    'gpu_memory': 8000,  # 8GB\n    'system_memory': 16384,  # 16GB\n    'storage_available': 100,  # 100GB\n    'platform': 'Linux'\n}\n\nvalidation_results = validator.validate_requirements(isaac_sim_requirements)\nprint(\"Isaac Sim Validation Results:\")\nfor requirement, passed in validation_results.items():\n    print(f\"  {requirement}: {'PASS' if passed else 'FAIL'}\")\n\nrecommendation = validator.get_recommendation(\"simulation\")\nprint(f\"\\\\nRecommendation: {recommendation}\")\n"})}),"\n",(0,o.jsx)(n.p,{children:'`}\ncopyable={true}\nexpandable={true}\nmaxHeight="400px"\n/>'})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var i=r(6540);const o={},t=i.createContext(o);function s(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);