"use strict";(globalThis.webpackChunkmy_web=globalThis.webpackChunkmy_web||[]).push([[2290],{5568:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"book/control-systems/index","title":"Control Systems","description":"Understanding control systems for humanoid robotics","source":"@site/docs/book/control-systems/index.md","sourceDirName":"book/control-systems","slug":"/book/control-systems/","permalink":"/physical-ai-robotics-textbook/docs/book/control-systems/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/book/control-systems/index.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Control Systems","sidebar_position":4,"description":"Understanding control systems for humanoid robotics"}}');var r=n(4848),i=n(8453);const l={title:"Control Systems",sidebar_position:4,description:"Understanding control systems for humanoid robotics"},s="Control Systems",a={},c=[{value:"Hardware for Control Systems",id:"hardware-for-control-systems",level:2},{value:"PID Controllers for Joint Control",id:"pid-controllers-for-joint-control",level:2},{value:"Control Architecture",id:"control-architecture",level:2},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:2},{value:"Zero Moment Point (ZMP) Control",id:"zero-moment-point-zmp-control",level:3},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3}];function d(e){const o={cmath:"cmath",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",iostream:"iostream",jointcontroller:"jointcontroller",p:"p",pre:"pre",technicaldiagrams:"technicaldiagrams",vector:"vector",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(o.p,{children:"import HardwareSpecs from '@site/src/components/HardwareSpecs/HardwareSpecs';\nimport CodeExamples from '@site/src/components/CodeExamples/CodeExamples';\nimport TechnicalDiagrams from '@site/src/components/TechnicalDiagrams/TechnicalDiagrams';"}),"\n",(0,r.jsx)(o.header,{children:(0,r.jsx)(o.h1,{id:"control-systems",children:"Control Systems"})}),"\n",(0,r.jsx)(o.p,{children:"Humanoid robotics control systems are complex multi-layered architectures that manage everything from low-level motor control to high-level task planning. This module explores the different control layers and their implementations."}),"\n",(0,r.jsx)(o.h2,{id:"hardware-for-control-systems",children:"Hardware for Control Systems"}),"\n",(0,r.jsx)(o.p,{children:'<HardwareSpecs\nname="Real-time Control Hardware"\ncategory="Motion Control Systems"\nspecs={{\ncontroller: "Beckhoff CX9020 or equivalent",\ncpu: "ARM Cortex-A9 1GHz",\nio: "Multiple digital and analog I/O ports",\ncommunication: "EtherCAT, CAN, Ethernet",\nrtos: "TwinCAT 3 with real-time Linux"\n}}\ncost={{\nprice: "$2,500-$4,000",\nreasoning: "Hard real-time requirements for humanoid robot motion control"\n}}\npros={[\n"Deterministic real-time performance",\n"Multiple communication protocols",\n"High I/O density",\n"Industrial reliability"\n]}\ncons={[\n"High cost",\n"Steep learning curve",\n"Requires specialized software (TwinCAT)",\n"Limited processing power compared to general-purpose computers"\n]}\n/>'}),"\n",(0,r.jsx)(o.h2,{id:"pid-controllers-for-joint-control",children:"PID Controllers for Joint Control"}),"\n",(0,r.jsx)(o.p,{children:"Proportional-Integral-Derivative (PID) controllers form the foundation of joint control in humanoid robots. These controllers ensure precise positioning and smooth motion."}),"\n",(0,r.jsxs)(o.p,{children:['<CodeExamples\ntitle="Advanced PID Controller for Joint Control"\ndescription="Implementation of a PID controller with feedforward compensation for humanoid robot joints"\nlanguage="cpp"\ncode={`#include ',(0,r.jsxs)(o.iostream,{children:["\n#include ",(0,r.jsxs)(o.vector,{children:["\n#include ",(0,r.jsx)(o.cmath,{})]})]})]}),"\n",(0,r.jsx)(o.p,{children:"class JointController {\nprivate:\ndouble kp_, ki_, kd_;\ndouble integral_, previous_error_;\ndouble feedforward_gain_;\ndouble max_integral_, min_integral_;\ndouble max_output_, min_output_;"}),"\n",(0,r.jsx)(o.p,{children:"public:\nJointController(double kp, double ki, double kd,\ndouble feedforward_gain = 0.0)\n: kp_(kp), ki_(ki), kd_(kd), feedforward_gain_(feedforward_gain),\nintegral_(0.0), previous_error_(0.0),\nmax_integral_(10.0), min_integral_(-10.0),\nmax_output_(10.0), min_output_(-10.0) {}"}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{children:"double update(double target_position, double current_position,\n              double target_velocity, double current_velocity,\n              double dt) {\n    double position_error = target_position - current_position;\n    double velocity_error = target_velocity - current_velocity;\n\n    // Proportional term\n    double p_term = kp_ * position_error;\n\n    // Integral term with anti-windup\n    integral_ += position_error * dt;\n    integral_ = std::clamp(integral_, min_integral_, max_integral_);\n    double i_term = ki_ * integral_;\n\n    // Derivative term (on measurement, not error, to avoid derivative kick)\n    double d_term = kd_ * (-current_velocity);\n\n    // Feedforward term\n    double ff_term = feedforward_gain_ * target_velocity;\n\n    // Calculate output\n    double output = p_term + i_term + d_term + ff_term;\n    output = std::clamp(output, min_output_, max_output_);\n\n    previous_error_ = position_error;\n\n    return output;\n}\n\nvoid reset() {\n    integral_ = 0.0;\n    previous_error_ = 0.0;\n}\n\nvoid setGains(double kp, double ki, double kd) {\n    kp_ = kp;\n    ki_ = ki;\n    kd_ = kd;\n}\n"})}),"\n",(0,r.jsx)(o.p,{children:"};"}),"\n",(0,r.jsxs)(o.p,{children:["// Example usage in a humanoid robot controller\nclass HumanoidController {\nprivate:\nstd::vector",(0,r.jsx)(o.jointcontroller,{children:" joint_controllers_;"})]}),"\n",(0,r.jsx)(o.p,{children:"public:\nHumanoidController() {\n// Initialize controllers for each joint\n// Example: left leg joints\njoint_controllers_.emplace_back(100.0, 0.1, 5.0); // hip\njoint_controllers_.emplace_back(80.0, 0.05, 3.0); // knee\njoint_controllers_.emplace_back(60.0, 0.02, 2.0); // ankle"}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{children:"    // Add more joints as needed\n}\n\nstd::vector<double> computeTorques(\n    const std::vector<double>& target_positions,\n    const std::vector<double>& current_positions,\n    const std::vector<double>& target_velocities,\n    const std::vector<double>& current_velocities,\n    double dt) {\n\n    std::vector<double> torques;\n    for (size_t i = 0; i < joint_controllers_.size(); ++i) {\n        double torque = joint_controllers_[i].update(\n            target_positions[i], current_positions[i],\n            target_velocities[i], current_velocities[i], dt);\n        torques.push_back(torque);\n    }\n    return torques;\n}\n"})}),"\n",(0,r.jsx)(o.p,{children:'};`}\ncopyable={true}\nexpandable={true}\nmaxHeight="400px"\n/>'}),"\n",(0,r.jsx)(o.h2,{id:"control-architecture",children:"Control Architecture"}),"\n",(0,r.jsx)(o.p,{children:(0,r.jsx)(o.technicaldiagrams,{title:"Hierarchical Control Architecture",description:"Three-level control architecture for humanoid robots: high-level planning, mid-level gait control, and low-level joint control",imageurl:"/img/control-architecture.png",caption:"Hierarchical control system showing the relationship between different control levels",alttext:"Hierarchical control architecture diagram",interactive:"{true}",zoomable:"{true}"})}),"\n",(0,r.jsx)(o.h2,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,r.jsx)(o.p,{children:"Generating stable walking patterns for humanoid robots requires sophisticated algorithms that consider balance, dynamics, and environmental constraints."}),"\n",(0,r.jsx)(o.h3,{id:"zero-moment-point-zmp-control",children:"Zero Moment Point (ZMP) Control"}),"\n",(0,r.jsx)(o.p,{children:"The Zero Moment Point is a critical concept in humanoid robotics that helps maintain balance during walking. The ZMP must remain within the support polygon defined by the feet to maintain stability."}),"\n",(0,r.jsx)(o.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,r.jsx)(o.p,{children:"Model Predictive Control is an advanced technique that uses a model of the robot's dynamics to predict future states and optimize control actions over a finite time horizon."})]})}function u(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,r.jsx)(o,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>l,x:()=>s});var t=n(6540);const r={},i=t.createContext(r);function l(e){const o=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function s(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(i.Provider,{value:o},e.children)}}}]);